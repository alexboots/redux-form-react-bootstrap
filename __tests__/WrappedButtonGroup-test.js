jest.unmock('../WrappedButtonGroup')

import React from 'react'

import {
  mount,
  shallow
} from 'enzyme'

import {
  Button,
  ButtonGroup,
  HelpBlock,
  ControlLabel
} from 'react-bootstrap'

import WrappedButtonGroup, {
  ROOT_CLASS,
  ACTIVE
} from '../WrappedButtonGroup'

describe('WrappedButtonGroup', () => {
  let wrapper
  let props

  let name = 'some boring name'
  let className = 'a-class-name'
  let options = [{ label: 'Foo', value: 'foo' }, { label: 'Bar', value: 'bar' }]
  let label = 'Some Label'
  let selectFirst = true

  let meta =  {
    touched: false,
    error: 'Some Error'
  }

  describe('initalize logic with input value and selectFirst', () => {

    let input = {
      name,
      value: options[1].value,
      onChange: jest.fn()
    }

    props = {
      options,
      label,
      className,
      input,
      selectFirst,
      meta
    }

    wrapper = mount(<WrappedButtonGroup { ...props } />)

    it('should initialize input.value if it exists and ignore selectFirst', () => {
      expect(input.onChange).not.toBeCalled()
    })
  })

  describe('initalize logic without input value, and with selectFirst', () => {

    let input = {
      name,
      value: '',
      onChange: jest.fn()
    }

    props = {
      options,
      label,
      className,
      input,
      selectFirst,
      meta
    }

    wrapper = mount(<WrappedButtonGroup { ...props } />)

    it('should initialize with first button selected if selectFirst is passed', () => {
      expect(input.onChange).toBeCalled()
      expect(input.onChange.mock.calls[0][0]).toBe(options[0].value)
    })
  })

  describe('rendered content', () => {

    // Input and Meta comes from redux-form Field
    let input = {
      name,
      value: '',
      onChange: jest.fn()
    }

    beforeAll(() => {
      props = {
        options,
        label,
        className,
        input,
        meta
      }

      wrapper = shallow(<WrappedButtonGroup { ...props } />)
    })

    afterAll(() => {
      props = undefined
      wrapper = undefined
    })

    it('should render `className` to the wrapper', () => {
      expect(wrapper.hasClass(className)).toBeTruthy()
    })

    it('should render a label if one is passed', () => {
      expect(wrapper.contains(label)).toBeTruthy()
    })

    it('should not render a label if one is not passed', () => {
      wrapper.setProps({ label: undefined })
      expect(wrapper.contains(label)).toBeFalsy()
    })

    describe('ButtonGroup / reactive behaviour', () => {
      it('should receive prop name', () => {
        let buttonGroupNode = wrapper.find(ButtonGroup)
        expect(buttonGroupNode.prop('name')).toEqual(name)
      })

      it('should display buttons based on what options contains', () => {
        let firstButton = wrapper.find(ButtonGroup).find(Button).first()
        let lastButton = wrapper.find(ButtonGroup).find(Button).last()
        expect(firstButton.contains(options[0].label)).toBeTruthy()
        expect(lastButton.contains(options[1].label)).toBeTruthy()
      })

      it('should pass value from options to input.onChange when button is clicked', () => {
        let firstButton = wrapper.find(ButtonGroup).find(Button).first()
        expect(input.onChange).not.toBeCalled()
        firstButton.simulate('click', { target: { value: options[0].value } })
        expect(input.onChange).toBeCalled()
        expect(input.onChange.mock.calls[0][0]).toBe(options[0].value)
      })

      it('should calculate the button width based on the number of buttons in options', () => {
        let firstButton = wrapper.find(ButtonGroup).find(Button).first()
        let widthNumber = parseInt(firstButton.prop('style').width)
        expect(widthNumber).toBe(100/options.length)
      })

      it('should have `ACTIVE` style if props input.value matches button value', () => {
        wrapper.setProps({ input: { value: options[0].value } })
        let firstButton = wrapper.find(ButtonGroup).find(Button).first()
        expect(firstButton.prop('className')).toBe(ACTIVE)
      })

      it('should not show an error if touched: false', () => {
        let helpBlock = wrapper.find(HelpBlock)
        expect(helpBlock.length).toBe(0)
      })

      it('should display an error', () => {
        // `touched` means the inputs onBlur has occured
        // The error is generated by `redux-form`'s validate(), which checks for validity every keyUp
        let meta =  {
          touched: true,
          error: 'Some Error'
        }

        wrapper.setProps({ meta })
        let helpBlock = wrapper.find(HelpBlock)
        expect(helpBlock.length).toBe(1)
        expect(helpBlock.contains(meta.error)).toBe(true)
      })
    })

  })
})
